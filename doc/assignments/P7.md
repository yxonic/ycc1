P7
===

### 7.1

1.  `Module`是最后生成的模块，而`IRBuilder<>`是负责向模块产生IR的一个
    生产者。所有的代码都通过`IRBuilder`产生。`IRBuilder`可以自动确定标
    号的名称，使得所有标号不会重复，此外，`IRBuilder`产生IR不一定是顺
    序的，它可以在任何时候切换插入点，这为复杂的程序流程提供了方便。

    变量的存储空间分配可以通过`IRBuilder::CreateAlloca`进行，分配的结
    果需要通过符号表记录下来，今后用到该变量时即可从符号表中取出，作为
    后续指令的操作数。符号表同时控制着作用域。Kaleidoscope的符号表就是
    一个简单的map，内层遇到相同符号时，它会先备份外层符号，然后退出这
    层作用域时恢复。

2.  同一个常量在LLVM中都有唯一表示，不需要每次创建。因此LLVM提供了一系
    列静态的get方法用于获取全局唯一的常量。

3.  定义函数，首先要得到一个函数类型（FunctionType），包括参数和返回值。
    由这个函数类型可以创建一个函数。之后创建入口点，便可以进行函数体内
    的代码生成。有返回值的函数要返回值。代码生成完毕，可以进行校验、执
    行优化。

4.  操作多个Block的方法并不复杂，首先函数内可以有很多程序点，并且可以
    通过BR进行跳转。需要时产生程序点（即Block），并设置IR插入位置
    （SetInsertBlock）。对于Kaleidoscope，即使是条件语句也有值，因此除
    了控制流，Block的返回值也很重要。最后的`ThenBB =
    Builder.GetInsertBlock()`是为了在子block中又进行了跳转后，仍然能获
    取到正确的值而写的。如果不使用PHI指令，那么这句话是不需要的。

5.  检查条件，为真进入真子句，为假进入假子句。真子句结束后跳回检查条件
    一步。

6.  Alloca分配内存只需要指派大小即可，编译器要自己记录名字和指派的空间
    的关系，因此需要符号表。多层嵌套的处理方式仍然是保存之前的结果，退
    出作用域后还原。


### 7.2

执行`make P7`即可看到结果。

### 7.3

介绍几个扩展的实现方式：

1.  逻辑表达式在文法上可以支持，而LLVM可以产生逻辑运算语句，它负责进行
    短路计算等功能。

2.  break和continue在我的代码中没有实现。实现方法大概是记录当前循环
    （顶层循环）的开始、结束位置，遇到语句进行相应跳转。然而这里还需要
    处理作用域的问题，看起来有点复杂。

3.  函数参数处理方式和局部变量几乎一样，需要分配空间，之后将实参载入。

4.  函数返回值只需要一条ret指令，然而对于多分支各自return，一般做法是
    延迟返回，返回值通过phi语句来确定。同样比较麻烦，因此没有实现。

5.  多维数组、float类型需要类型系统支持，而我之前没有实现类型系统，因
    此这两个也没有实现。
