# Go Runtime

## 准备工作

使用如下指令编译Go程序，可以得到（伪）汇编代码，根据汇编代码可以对Go运
行时API的使用有所了解：

    $ go tool 6g -S x.go

这种汇编代码中，有几个符号需要注意：SB (static base)用来表示静态数据区
的基址，FP (frame pointer)用来表示函数参数基址，SP (stack pointer)表示
局部数据的基址。用foo(SB)表示一个叫foo的全局名字，foo<>(SB)表示一个
static的全局名字，0(FP), 8(FP)分别表示第一个、第二个参数（64位系统上），
x-8(SP)表示位于-8位置的叫x的局部名字。

函数、全局变量分别为下面的结构：

    TEXT runtime·profileloop(SB),NOSPLIT,$8
            MOVQ    $runtime·profileloop1(SB), CX
            MOVQ    CX, 0(SP)
            CALL    runtime·externalthreadhandler(SB)
            RET
        
    DATA symbol+offset(SB)/width, value

细节参考`doc/asm.html`。

## Go调度器

Go调度器主要在`src/runtime/proc.c`中实现，有关机器的细节分散在
`asm_ARCH.s`, `sys_OS_ARCH.s`之中。我们且以linux下的amd64架构为例。

Go调度器最重要的三个数据结构分别为G、M和P。

G对应于goroutine，是抽象的任务。M对应系统线程（在linux下即进程），它负
责执行G。G只保存任务本身的信息，执行时必须绑定到M上。而底层的处理器对
应P，M执行时绑定于P之上。这个设计的细节后面还会提到。

调度器的调度算法基于任务窃取。于是，调度器本身的工作比较容易，即找一个
等待中的任务，执行它。整个工作由`proc.c`中的`schedule()`实现。这个函数
选择一个任务g（通过`runtime.findrunnable`），然后调用`execute()`，其中
调用`runtime.gogo`实际执行，这个汇编函数会直接修改栈为g的栈（在这之前
将返回地址设为`goexit`，从而在G结束时做一些清理工作），从而（继续）执
行g。于是，我们开始时需要建立一个定时调用`schedule`的守护进程，即
`newsysmon`（它也包括了垃圾回收等功能）。当然也可以主动调用
`schedule`释放控制。大致的情况如此，下面具体再分析一下。

Go程序启动时的基本流程如下：

1.  osinit （设定核心数）
2.  schedinit （初始化调度用的各个数据结构，此时初始化一个M结构但不执
    行）
3.  make & queue new G （调用`runtime.newproc`，在调度器中加入第一个G，
    即`runtime.main`。它会开启`newsysmon`，之后调用真正的`main`。这个G
    不会立刻执行）
4.  `runtime.mstart` （执行M上面的g，于是整个程序开始运行）

Go中的函数调用有两种形式，第一种形式与C语言没有什么区别；第二种，语法
为`go f(...)`，则将f以及f的参数入栈，之后调用`runtime.newproc`。
`newproc`负责建立新的G，然后调用`runtime.onM`去在M上执行`newproc1`。
`onM`执行之后会返回调用点。注意区别这个函数和同样用于执行其他任务的之
前提到的`runtime.gogo`函数。

G的创建（实际在`runtime.newproc1`中），默认会复用之前的G对象，这个空闲
的对象来自P的cache（这是为什么有了M仍然需要P结构的一个理由：M对应的系
统进程不一定在同一个CPU上执行，于是寄存器、cache信息不宜保存于M中）。
当然，如果没有之前的cache，就新建一个G（通过`malg`分派空间）。特别注明，
新G的栈空间是非常小的（2KB），只有需要时才会扩大，这允许一个程序运行相
当大量的G。

新建好的G被放置到当前P的待运行队列中（`runqput`）。而P的待运行队列是分
级的，分别是下一个执行的任务、P的本地队列、全局队列。前两个由于限定于
本CPU，是不需要加锁访问的。如果P的本地队列满，那么说明P比较忙，这时执
行`runqputslow`，专门负责把一半任务分到全局队列，没有任务执行的P这时就
可以去执行这些任务了。因此，这一切结束前，应当唤醒空闲的P。

唤醒P调用了`wakep`函数。它最终在某个P上调用了`startm`，基本逻辑为找到
一个M，然后执行它。没有空闲M则新建一个（通过`newm`，正是这里建立了系统
进程，在linux下，此处调用了`clone`函数）。从此，正常情况下，这个新的M
便会一直跑在这个空闲的P上，进行完整的调度逻辑。然而没有任务、阻塞过久
等情况时，M的P会被夺走，于是这个M便空闲出来。它之后可以被再次`mstart`。

下面接着具体看看`runtime.mstart`的行为。`mstart`做一些初始化工作，之后
便调用了`schedule`函数。它的机制开始提到过了。补充一点，基于之前提到的
G队列，我们可以知道，`findrunnable`会先从本地队列拿任务，没有的话去到
全局队列，这时如果还没有任务，那么它会去主动窃取其他P上的任务。

最后讨论一下`sysmon`，它实际上是一个M，即一个进程。它不是通过
`newproc`而是直接通过`onM`执行的，于是它只是一个负责监控的进程，不会参
与G的调度。相反，它可以控制G的调度，主要是负责从M中收回长时间阻塞的P，
对运行时间太长的G发起调度，等等。

## chan的实现

`chan`主要在`src/runtime/chan.go`中实现。

Go语言的channel实现并非针对高性能并行设计，而是为了实现高度并发环境下
的通信设计的，它只是掩盖了底层的线程、锁等机制，提供一个易于使用的通信
模式。它类似Unix的管道，在进程间提供了最基础的通信服务，但是比管道拥有
更多的特性，比如支持类型。但是它不直接支持大部分并行模式，如基于共享变
量的并行模式及广播等模式（不过，由于Go是系统级语言，可以使用Go实现这样
的库或工具）。实现高性能并行主要需要靠用户的正确使用。

底层的执行基于进程，因此全部的通信基于内存复制而非内存共享。当然，由于
可以在channel中传递指针，亦即传递一块内存，事实上内存共享模式也是支持
的。我们后面再分析效率上的问题。

现在，我们具体看一下Go中chan的实现机制。

Channel实现中信息由记录类型Hchan保存，其中记录如下一些信息：channel容
量、类型、元素buffer、接收队列、发送队列。

Go中的channel分为三种类型。下面是三种类型分别的示例：

    c1 := make(chan int)
    c2 := make(chan int, 10)
    c3 := make(chan struct{})
    
具体分析三种channel：

注意到，第一种channel中只有一个空位，即表示内容传输始终是一对一的，只
要运行时确定一对发送者和接收者（各自取队首的g），然后直接转交，进行一
次内存复制即可。由于没有竞争，这里使用最简单的加锁实现，不会影响性能。
如果没有匹配，则将一个sudog加入发送者/接收者队列。sudog是可以被复用的，
它负责等待配对者出现而被唤醒。

第二种channel有一个元素buffer，这是个传统的生产者消费者模式，为了性能，
给整个buffer加锁是不理想的。于是这里采用了CAS操作来实现无锁访问。以
send为例，在buffer未满的情况下，各个sender竞争写sendx，竞争到的进行一
次（不需要加锁的）写操作。读也是一样。如果buffer满了，则休眠等待唤醒。

第三种和第二种是类似的，只是不需要存储数据。它就作为信号量来使用。

上面都实现于runtime.chansend、runtime.chanrecv函数中。

自然，我们还需要实现一个高效的select。首先对所有channel进行shuffle。之
后先对每一个channel尝试执行非阻塞的通信，如果失败（即等待的channel全部
阻塞），则在每个channel的等待列表中加入自己，并阻塞，等待之后被唤醒。
整个操作不需要对channel全部加锁，在很多情况下都不需要访问每个channel。

