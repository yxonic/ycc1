P3
===

1. ExprAST为抽象类，因为其中的函数都被声明为纯虚函数。于是ExprAST作为
   所有AST节点的抽象基类，提供两个可被实现的接口（通过对virtual方法的
   override）。两个接口一个负责生成中间代码，一个负责输出Dot结构图。虚
   函数实现时原理如下：每个类维护虚函数表（vtable），表中存储了类方法
   的指针。对于虚函数，继承时，这个指针会被覆盖。而通过父类指针或者引
   用调用方法时会查询该虚函数表，根据记录的指针访问函数，这就实现了多
   态。
   
2. HandleDefinition对应文法中的definition，HandleTopLevelExpression对
   应文法中的expression。

3. Token类型通过getNextToken获得，对应内容通过IdentifierStr、NumVal传
   递。

4. 运算符的优先级通过一个字典BinopPrecedence来记录。ParseBinOpRHS在没
   有限定（优先级相同）的情况下是左结合的。所以如果下一个运算的优先级
   不大于当前的优先级，那么就把下一个primary合并到之前的左部分（LHS）。
   如果下一个优先级大，那么就需要执行ParseBinOpRHS把高于这个优先级的部
   分读取到，全部读到的结果作为RHS输入。具体而言，对于a\*b\*c，LHS等于
   a，读到b成为a\*b，读到c则由原来的LHS与c拼合，最后返回。a\*b+c同理。
   a+b\*c处理时，则由于\*的优先级高，会将RHS置为b\*c，然后与LHS（a）拼
   合。

5. 它们都返回空指针，存在三个主要理由是要返回三种不同类型，但是作用是
   相同的。如果正确解读，那么会返回相应的指针，故返回空指针意味着错误。
   每层遇到空指针都会向上返回，最后程序会终止于此。Error函数在返回空指
   针时允许输出一句话表明错误原因。

6. 变量出现在函数声明以及for...in...表达式中，用于作为输入的指示或者迭
   代内容的指代。

7. 这个语言不存在语句的概念，因此不需要语句分割、打包。表达式可以通过
   普通的括号来打包。

8. Kaleidoscope语言的if/then/else并不存在二义的问题，因为这里else语句
   是必须的而不是可选的，于是不存在不知道else与哪个if匹配的问题（一定
   匹配给最后一个未被匹配的if）。参考Codegen部分可以知道，if语句判断在
   表达式大于0时为真，否则为假。
